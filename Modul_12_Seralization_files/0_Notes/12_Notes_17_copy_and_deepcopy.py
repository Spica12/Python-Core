print('--- Example 1 --------------------------')
my_list = [1, 2, 3]
copy_list = my_list
copy_list.append(4)
print(f'{my_list = }\n{copy_list = }')
# копіюється лише посилання на об'єкт

print('--- Example 2 --------------------------')
my_list = [1, 2, 3, [4, 5]]
copy_list = my_list[:]
copy_list[3][0] = 5
print(f'{my_list = }\n{copy_list = }')
# копіює тільки не змінювані об'єкти, змінюванні копіюється знов ж таки посилання

print('--- Example 3 --------------------------')
dict_1 = {'d': 2, 'c': 4}
copy_dict_1 = {**dict_1}
copy_dict_1['d'] = 4

copy_list[3][0] = 5
print(f'{dict_1 = }\n{copy_dict_1 = }')

print('--- Example 4 --------------------------')
# Поверхнева копія
# Щоб створити "поверхневу" копію об'єкта, у пакеті copy є функція copy. Ця функція 
# створює новий об'єкт такого самого типу і потім створює посилання на увесь вміст 
# старого об'єкта в новий. Такий механізм досить хороший для роботи з об'єктами, 
# де вже на першому рівні вкладеності немає змінних об'єктів, і він працює досить 
# швидко. Але для об'єктів із глибокою вкладеністю така функція все ж таки не дасть 
# потрібного ефекту:

import copy
my_list = [1, 2, {'1': 'abc'}]
copy_list = copy.copy(my_list)
copy_list.append(4)
copy_list[2]['1'] = 'bcd'
print(f'{my_list = }\n{copy_list = }')
# На першому рівні все нормально, а на другому копіюється посилання

print('--- Example 5 --------------------------')
# Глибока копія
# Для ситуацій, коли нам потрібно, щоб на будь-якому рівні вкладеності створювалися 
# нові об'єкти, а не посилання на існуючі, у пакеті copy є функція deepcopy. 
# Ця функція рекурсивно створює нові об'єкти.

import copy

my_list = [1, 2, {'1': 'abc'}]
copy_list = copy.deepcopy(my_list)
copy_list.append(4)
copy_list[2]['1'] = 'bcd'
print(f'{my_list = }\n{copy_list = }')
# два списки повністю різні

